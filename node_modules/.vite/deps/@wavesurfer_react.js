import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/@wavesurfer/react/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());

// node_modules/wavesurfer.js/dist/wavesurfer.esm.js
function t(t3, e3, i3, s2) {
  return new (i3 || (i3 = Promise))(function(n3, r3) {
    function o3(t4) {
      try {
        h2(s2.next(t4));
      } catch (t5) {
        r3(t5);
      }
    }
    function a3(t4) {
      try {
        h2(s2.throw(t4));
      } catch (t5) {
        r3(t5);
      }
    }
    function h2(t4) {
      var e4;
      t4.done ? n3(t4.value) : (e4 = t4.value, e4 instanceof i3 ? e4 : new i3(function(t5) {
        t5(e4);
      })).then(o3, a3);
    }
    h2((s2 = s2.apply(t3, e3 || [])).next());
  });
}
var e = class {
  constructor() {
    this.listeners = {};
  }
  on(t3, e3, i3) {
    if (this.listeners[t3] || (this.listeners[t3] = /* @__PURE__ */ new Set()), this.listeners[t3].add(e3), null == i3 ? void 0 : i3.once) {
      const i4 = () => {
        this.un(t3, i4), this.un(t3, e3);
      };
      return this.on(t3, i4), i4;
    }
    return () => this.un(t3, e3);
  }
  un(t3, e3) {
    var i3;
    null === (i3 = this.listeners[t3]) || void 0 === i3 || i3.delete(e3);
  }
  once(t3, e3) {
    return this.on(t3, e3, { once: true });
  }
  unAll() {
    this.listeners = {};
  }
  emit(t3, ...e3) {
    this.listeners[t3] && this.listeners[t3].forEach((t4) => t4(...e3));
  }
};
var i = { decode: function(e3, i3) {
  return t(this, void 0, void 0, function* () {
    const t3 = new AudioContext({ sampleRate: i3 });
    return t3.decodeAudioData(e3).finally(() => t3.close());
  });
}, createBuffer: function(t3, e3) {
  return "number" == typeof t3[0] && (t3 = [t3]), function(t4) {
    const e4 = t4[0];
    if (e4.some((t5) => t5 > 1 || t5 < -1)) {
      const i3 = e4.length;
      let s2 = 0;
      for (let t5 = 0; t5 < i3; t5++) {
        const i4 = Math.abs(e4[t5]);
        i4 > s2 && (s2 = i4);
      }
      for (const e5 of t4) for (let t5 = 0; t5 < i3; t5++) e5[t5] /= s2;
    }
  }(t3), { duration: e3, length: t3[0].length, sampleRate: t3[0].length / e3, numberOfChannels: t3.length, getChannelData: (e4) => null == t3 ? void 0 : t3[e4], copyFromChannel: AudioBuffer.prototype.copyFromChannel, copyToChannel: AudioBuffer.prototype.copyToChannel };
} };
function s(t3, e3) {
  const i3 = e3.xmlns ? document.createElementNS(e3.xmlns, t3) : document.createElement(t3);
  for (const [t4, n3] of Object.entries(e3)) if ("children" === t4) for (const [t5, n4] of Object.entries(e3)) "string" == typeof n4 ? i3.appendChild(document.createTextNode(n4)) : i3.appendChild(s(t5, n4));
  else "style" === t4 ? Object.assign(i3.style, n3) : "textContent" === t4 ? i3.textContent = n3 : i3.setAttribute(t4, n3.toString());
  return i3;
}
function n(t3, e3, i3) {
  const n3 = s(t3, e3 || {});
  return null == i3 || i3.appendChild(n3), n3;
}
var r = Object.freeze({ __proto__: null, createElement: n, default: n });
var o = { fetchBlob: function(e3, i3, s2) {
  return t(this, void 0, void 0, function* () {
    const n3 = yield fetch(e3, s2);
    if (n3.status >= 400) throw new Error(`Failed to fetch ${e3}: ${n3.status} (${n3.statusText})`);
    return function(e4, i4) {
      t(this, void 0, void 0, function* () {
        if (!e4.body || !e4.headers) return;
        const s3 = e4.body.getReader(), n4 = Number(e4.headers.get("Content-Length")) || 0;
        let r3 = 0;
        const o3 = (e5) => t(this, void 0, void 0, function* () {
          r3 += (null == e5 ? void 0 : e5.length) || 0;
          const t3 = Math.round(r3 / n4 * 100);
          i4(t3);
        }), a3 = () => t(this, void 0, void 0, function* () {
          let t3;
          try {
            t3 = yield s3.read();
          } catch (t4) {
            return;
          }
          t3.done || (o3(t3.value), yield a3());
        });
        a3();
      });
    }(n3.clone(), i3), n3.blob();
  });
} };
var a = class extends e {
  constructor(t3) {
    super(), this.isExternalMedia = false, t3.media ? (this.media = t3.media, this.isExternalMedia = true) : this.media = document.createElement("audio"), t3.mediaControls && (this.media.controls = true), t3.autoplay && (this.media.autoplay = true), null != t3.playbackRate && this.onMediaEvent("canplay", () => {
      null != t3.playbackRate && (this.media.playbackRate = t3.playbackRate);
    }, { once: true });
  }
  onMediaEvent(t3, e3, i3) {
    return this.media.addEventListener(t3, e3, i3), () => this.media.removeEventListener(t3, e3, i3);
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const t3 = this.getSrc();
    t3.startsWith("blob:") && URL.revokeObjectURL(t3);
  }
  canPlayType(t3) {
    return "" !== this.media.canPlayType(t3);
  }
  setSrc(t3, e3) {
    const i3 = this.getSrc();
    if (t3 && i3 === t3) return;
    this.revokeSrc();
    const s2 = e3 instanceof Blob && (this.canPlayType(e3.type) || !t3) ? URL.createObjectURL(e3) : t3;
    try {
      this.media.src = s2;
    } catch (e4) {
      this.media.src = t3;
    }
  }
  destroy() {
    this.media.pause(), this.isExternalMedia || (this.media.remove(), this.revokeSrc(), this.media.src = "", this.media.load());
  }
  setMediaElement(t3) {
    this.media = t3;
  }
  play() {
    return t(this, void 0, void 0, function* () {
      return this.media.play();
    });
  }
  pause() {
    this.media.pause();
  }
  isPlaying() {
    return !this.media.paused && !this.media.ended;
  }
  setTime(t3) {
    this.media.currentTime = t3;
  }
  getDuration() {
    return this.media.duration;
  }
  getCurrentTime() {
    return this.media.currentTime;
  }
  getVolume() {
    return this.media.volume;
  }
  setVolume(t3) {
    this.media.volume = t3;
  }
  getMuted() {
    return this.media.muted;
  }
  setMuted(t3) {
    this.media.muted = t3;
  }
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  isSeeking() {
    return this.media.seeking;
  }
  setPlaybackRate(t3, e3) {
    null != e3 && (this.media.preservesPitch = e3), this.media.playbackRate = t3;
  }
  getMediaElement() {
    return this.media;
  }
  setSinkId(t3) {
    return this.media.setSinkId(t3);
  }
};
var h = class _h extends e {
  constructor(t3, e3) {
    super(), this.timeouts = [], this.isScrollable = false, this.audioData = null, this.resizeObserver = null, this.lastContainerWidth = 0, this.isDragging = false, this.subscriptions = [], this.unsubscribeOnScroll = [], this.subscriptions = [], this.options = t3;
    const i3 = this.parentFromOptionsContainer(t3.container);
    this.parent = i3;
    const [s2, n3] = this.initHtml();
    i3.appendChild(s2), this.container = s2, this.scrollContainer = n3.querySelector(".scroll"), this.wrapper = n3.querySelector(".wrapper"), this.canvasWrapper = n3.querySelector(".canvases"), this.progressWrapper = n3.querySelector(".progress"), this.cursor = n3.querySelector(".cursor"), e3 && n3.appendChild(e3), this.initEvents();
  }
  parentFromOptionsContainer(t3) {
    let e3;
    if ("string" == typeof t3 ? e3 = document.querySelector(t3) : t3 instanceof HTMLElement && (e3 = t3), !e3) throw new Error("Container not found");
    return e3;
  }
  initEvents() {
    const t3 = (t4) => {
      const e3 = this.wrapper.getBoundingClientRect(), i3 = t4.clientX - e3.left, s2 = t4.clientY - e3.top;
      return [i3 / e3.width, s2 / e3.height];
    };
    if (this.wrapper.addEventListener("click", (e3) => {
      const [i3, s2] = t3(e3);
      this.emit("click", i3, s2);
    }), this.wrapper.addEventListener("dblclick", (e3) => {
      const [i3, s2] = t3(e3);
      this.emit("dblclick", i3, s2);
    }), true !== this.options.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
      const { scrollLeft: t4, scrollWidth: e3, clientWidth: i3 } = this.scrollContainer, s2 = t4 / e3, n3 = (t4 + i3) / e3;
      this.emit("scroll", s2, n3, t4, t4 + i3);
    }), "function" == typeof ResizeObserver) {
      const t4 = this.createDelay(100);
      this.resizeObserver = new ResizeObserver(() => {
        t4().then(() => this.onContainerResize()).catch(() => {
        });
      }), this.resizeObserver.observe(this.scrollContainer);
    }
  }
  onContainerResize() {
    const t3 = this.parent.clientWidth;
    t3 === this.lastContainerWidth && "auto" !== this.options.height || (this.lastContainerWidth = t3, this.reRender());
  }
  initDrag() {
    this.subscriptions.push(function(t3, e3, i3, s2, n3 = 3, r3 = 0, o3 = 100) {
      if (!t3) return () => {
      };
      const a3 = matchMedia("(pointer: coarse)").matches;
      let h2 = () => {
      };
      const l3 = (l4) => {
        if (l4.button !== r3) return;
        l4.preventDefault(), l4.stopPropagation();
        let d2 = l4.clientX, c3 = l4.clientY, u3 = false;
        const p2 = Date.now(), m = (s3) => {
          if (s3.preventDefault(), s3.stopPropagation(), a3 && Date.now() - p2 < o3) return;
          const r4 = s3.clientX, h3 = s3.clientY, l5 = r4 - d2, m2 = h3 - c3;
          if (u3 || Math.abs(l5) > n3 || Math.abs(m2) > n3) {
            const s4 = t3.getBoundingClientRect(), { left: n4, top: o4 } = s4;
            u3 || (null == i3 || i3(d2 - n4, c3 - o4), u3 = true), e3(l5, m2, r4 - n4, h3 - o4), d2 = r4, c3 = h3;
          }
        }, f2 = (e4) => {
          if (u3) {
            const i4 = e4.clientX, n4 = e4.clientY, r4 = t3.getBoundingClientRect(), { left: o4, top: a4 } = r4;
            null == s2 || s2(i4 - o4, n4 - a4);
          }
          h2();
        }, g = (t4) => {
          t4.relatedTarget && t4.relatedTarget !== document.documentElement || f2(t4);
        }, v = (t4) => {
          u3 && (t4.stopPropagation(), t4.preventDefault());
        }, b = (t4) => {
          u3 && t4.preventDefault();
        };
        document.addEventListener("pointermove", m), document.addEventListener("pointerup", f2), document.addEventListener("pointerout", g), document.addEventListener("pointercancel", g), document.addEventListener("touchmove", b, { passive: false }), document.addEventListener("click", v, { capture: true }), h2 = () => {
          document.removeEventListener("pointermove", m), document.removeEventListener("pointerup", f2), document.removeEventListener("pointerout", g), document.removeEventListener("pointercancel", g), document.removeEventListener("touchmove", b), setTimeout(() => {
            document.removeEventListener("click", v, { capture: true });
          }, 10);
        };
      };
      return t3.addEventListener("pointerdown", l3), () => {
        h2(), t3.removeEventListener("pointerdown", l3);
      };
    }(this.wrapper, (t3, e3, i3) => {
      this.emit("drag", Math.max(0, Math.min(1, i3 / this.wrapper.getBoundingClientRect().width)));
    }, (t3) => {
      this.isDragging = true, this.emit("dragstart", Math.max(0, Math.min(1, t3 / this.wrapper.getBoundingClientRect().width)));
    }, (t3) => {
      this.isDragging = false, this.emit("dragend", Math.max(0, Math.min(1, t3 / this.wrapper.getBoundingClientRect().width)));
    }));
  }
  getHeight(t3, e3) {
    var i3;
    const s2 = (null === (i3 = this.audioData) || void 0 === i3 ? void 0 : i3.numberOfChannels) || 1;
    if (null == t3) return 128;
    if (!isNaN(Number(t3))) return Number(t3);
    if ("auto" === t3) {
      const t4 = this.parent.clientHeight || 128;
      return (null == e3 ? void 0 : e3.every((t5) => !t5.overlay)) ? t4 / s2 : t4;
    }
    return 128;
  }
  initHtml() {
    const t3 = document.createElement("div"), e3 = t3.attachShadow({ mode: "open" }), i3 = this.options.cspNonce && "string" == typeof this.options.cspNonce ? this.options.cspNonce.replace(/"/g, "") : "";
    return e3.innerHTML = `
      <style${i3 ? ` nonce="${i3}"` : ""}>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height, this.options.splitChannels)}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [t3, e3];
  }
  setOptions(t3) {
    if (this.options.container !== t3.container) {
      const e3 = this.parentFromOptionsContainer(t3.container);
      e3.appendChild(this.container), this.parent = e3;
    }
    true !== t3.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag(), this.options = t3, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getWidth() {
    return this.scrollContainer.clientWidth;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  setScroll(t3) {
    this.scrollContainer.scrollLeft = t3;
  }
  setScrollPercentage(t3) {
    const { scrollWidth: e3 } = this.scrollContainer, i3 = e3 * t3;
    this.setScroll(i3);
  }
  destroy() {
    var t3, e3;
    this.subscriptions.forEach((t4) => t4()), this.container.remove(), null === (t3 = this.resizeObserver) || void 0 === t3 || t3.disconnect(), null === (e3 = this.unsubscribeOnScroll) || void 0 === e3 || e3.forEach((t4) => t4()), this.unsubscribeOnScroll = [];
  }
  createDelay(t3 = 10) {
    let e3, i3;
    const s2 = () => {
      e3 && clearTimeout(e3), i3 && i3();
    };
    return this.timeouts.push(s2), () => new Promise((n3, r3) => {
      s2(), i3 = r3, e3 = setTimeout(() => {
        e3 = void 0, i3 = void 0, n3();
      }, t3);
    });
  }
  convertColorValues(t3) {
    if (!Array.isArray(t3)) return t3 || "";
    if (t3.length < 2) return t3[0] || "";
    const e3 = document.createElement("canvas"), i3 = e3.getContext("2d"), s2 = e3.height * (window.devicePixelRatio || 1), n3 = i3.createLinearGradient(0, 0, 0, s2), r3 = 1 / (t3.length - 1);
    return t3.forEach((t4, e4) => {
      const i4 = e4 * r3;
      n3.addColorStop(i4, t4);
    }), n3;
  }
  getPixelRatio() {
    return Math.max(1, window.devicePixelRatio || 1);
  }
  renderBarWaveform(t3, e3, i3, s2) {
    const n3 = t3[0], r3 = t3[1] || t3[0], o3 = n3.length, { width: a3, height: h2 } = i3.canvas, l3 = h2 / 2, d2 = this.getPixelRatio(), c3 = e3.barWidth ? e3.barWidth * d2 : 1, u3 = e3.barGap ? e3.barGap * d2 : e3.barWidth ? c3 / 2 : 0, p2 = e3.barRadius || 0, m = a3 / (c3 + u3) / o3, f2 = p2 && "roundRect" in i3 ? "roundRect" : "rect";
    i3.beginPath();
    let g = 0, v = 0, b = 0;
    for (let t4 = 0; t4 <= o3; t4++) {
      const o4 = Math.round(t4 * m);
      if (o4 > g) {
        const t5 = Math.round(v * l3 * s2), n4 = t5 + Math.round(b * l3 * s2) || 1;
        let r4 = l3 - t5;
        "top" === e3.barAlign ? r4 = 0 : "bottom" === e3.barAlign && (r4 = h2 - n4), i3[f2](g * (c3 + u3), r4, c3, n4, p2), g = o4, v = 0, b = 0;
      }
      const a4 = Math.abs(n3[t4] || 0), d3 = Math.abs(r3[t4] || 0);
      a4 > v && (v = a4), d3 > b && (b = d3);
    }
    i3.fill(), i3.closePath();
  }
  renderLineWaveform(t3, e3, i3, s2) {
    const n3 = (e4) => {
      const n4 = t3[e4] || t3[0], r3 = n4.length, { height: o3 } = i3.canvas, a3 = o3 / 2, h2 = i3.canvas.width / r3;
      i3.moveTo(0, a3);
      let l3 = 0, d2 = 0;
      for (let t4 = 0; t4 <= r3; t4++) {
        const r4 = Math.round(t4 * h2);
        if (r4 > l3) {
          const t5 = a3 + (Math.round(d2 * a3 * s2) || 1) * (0 === e4 ? -1 : 1);
          i3.lineTo(l3, t5), l3 = r4, d2 = 0;
        }
        const o4 = Math.abs(n4[t4] || 0);
        o4 > d2 && (d2 = o4);
      }
      i3.lineTo(l3, a3);
    };
    i3.beginPath(), n3(0), n3(1), i3.fill(), i3.closePath();
  }
  renderWaveform(t3, e3, i3) {
    if (i3.fillStyle = this.convertColorValues(e3.waveColor), e3.renderFunction) return void e3.renderFunction(t3, i3);
    let s2 = e3.barHeight || 1;
    if (e3.normalize) {
      const e4 = Array.from(t3[0]).reduce((t4, e5) => Math.max(t4, Math.abs(e5)), 0);
      s2 = e4 ? 1 / e4 : 1;
    }
    e3.barWidth || e3.barGap || e3.barAlign ? this.renderBarWaveform(t3, e3, i3, s2) : this.renderLineWaveform(t3, e3, i3, s2);
  }
  renderSingleCanvas(t3, e3, i3, s2, n3, r3, o3) {
    const a3 = this.getPixelRatio(), h2 = document.createElement("canvas");
    h2.width = Math.round(i3 * a3), h2.height = Math.round(s2 * a3), h2.style.width = `${i3}px`, h2.style.height = `${s2}px`, h2.style.left = `${Math.round(n3)}px`, r3.appendChild(h2);
    const l3 = h2.getContext("2d");
    if (this.renderWaveform(t3, e3, l3), h2.width > 0 && h2.height > 0) {
      const t4 = h2.cloneNode(), i4 = t4.getContext("2d");
      i4.drawImage(h2, 0, 0), i4.globalCompositeOperation = "source-in", i4.fillStyle = this.convertColorValues(e3.progressColor), i4.fillRect(0, 0, h2.width, h2.height), o3.appendChild(t4);
    }
  }
  renderMultiCanvas(t3, e3, i3, s2, n3, r3) {
    const o3 = this.getPixelRatio(), { clientWidth: a3 } = this.scrollContainer, l3 = i3 / o3;
    let d2 = Math.min(_h.MAX_CANVAS_WIDTH, a3, l3), c3 = {};
    if (0 === d2) return;
    if (e3.barWidth || e3.barGap) {
      const t4 = e3.barWidth || 0.5, i4 = t4 + (e3.barGap || t4 / 2);
      d2 % i4 != 0 && (d2 = Math.floor(d2 / i4) * i4);
    }
    const u3 = (i4) => {
      if (i4 < 0 || i4 >= p2) return;
      if (c3[i4]) return;
      c3[i4] = true;
      const o4 = i4 * d2, a4 = Math.min(l3 - o4, d2);
      if (a4 <= 0) return;
      const h2 = t3.map((t4) => {
        const e4 = Math.floor(o4 / l3 * t4.length), i5 = Math.floor((o4 + a4) / l3 * t4.length);
        return t4.slice(e4, i5);
      });
      this.renderSingleCanvas(h2, e3, a4, s2, o4, n3, r3);
    }, p2 = Math.ceil(l3 / d2);
    if (!this.isScrollable) {
      for (let t4 = 0; t4 < p2; t4++) u3(t4);
      return;
    }
    const m = this.scrollContainer.scrollLeft / l3, f2 = Math.floor(m * p2);
    if (u3(f2 - 1), u3(f2), u3(f2 + 1), p2 > 1) {
      const t4 = this.on("scroll", () => {
        const { scrollLeft: t5 } = this.scrollContainer, e4 = Math.floor(t5 / l3 * p2);
        Object.keys(c3).length > _h.MAX_NODES && (n3.innerHTML = "", r3.innerHTML = "", c3 = {}), u3(e4 - 1), u3(e4), u3(e4 + 1);
      });
      this.unsubscribeOnScroll.push(t4);
    }
  }
  renderChannel(t3, e3, i3, s2) {
    var { overlay: n3 } = e3, r3 = function(t4, e4) {
      var i4 = {};
      for (var s3 in t4) Object.prototype.hasOwnProperty.call(t4, s3) && e4.indexOf(s3) < 0 && (i4[s3] = t4[s3]);
      if (null != t4 && "function" == typeof Object.getOwnPropertySymbols) {
        var n4 = 0;
        for (s3 = Object.getOwnPropertySymbols(t4); n4 < s3.length; n4++) e4.indexOf(s3[n4]) < 0 && Object.prototype.propertyIsEnumerable.call(t4, s3[n4]) && (i4[s3[n4]] = t4[s3[n4]]);
      }
      return i4;
    }(e3, ["overlay"]);
    const o3 = document.createElement("div"), a3 = this.getHeight(r3.height, r3.splitChannels);
    o3.style.height = `${a3}px`, n3 && s2 > 0 && (o3.style.marginTop = `-${a3}px`), this.canvasWrapper.style.minHeight = `${a3}px`, this.canvasWrapper.appendChild(o3);
    const h2 = o3.cloneNode();
    this.progressWrapper.appendChild(h2), this.renderMultiCanvas(t3, r3, i3, a3, o3, h2);
  }
  render(e3) {
    return t(this, void 0, void 0, function* () {
      var t3;
      this.timeouts.forEach((t4) => t4()), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", null != this.options.width && (this.scrollContainer.style.width = "number" == typeof this.options.width ? `${this.options.width}px` : this.options.width);
      const i3 = this.getPixelRatio(), s2 = this.scrollContainer.clientWidth, n3 = Math.ceil(e3.duration * (this.options.minPxPerSec || 0));
      this.isScrollable = n3 > s2;
      const r3 = this.options.fillParent && !this.isScrollable, o3 = (r3 ? s2 : n3) * i3;
      if (this.wrapper.style.width = r3 ? "100%" : `${n3}px`, this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.audioData = e3, this.emit("render"), this.options.splitChannels) for (let i4 = 0; i4 < e3.numberOfChannels; i4++) {
        const s3 = Object.assign(Object.assign({}, this.options), null === (t3 = this.options.splitChannels) || void 0 === t3 ? void 0 : t3[i4]);
        this.renderChannel([e3.getChannelData(i4)], s3, o3, i4);
      }
      else {
        const t4 = [e3.getChannelData(0)];
        e3.numberOfChannels > 1 && t4.push(e3.getChannelData(1)), this.renderChannel(t4, this.options, o3, 0);
      }
      Promise.resolve().then(() => this.emit("rendered"));
    });
  }
  reRender() {
    if (this.unsubscribeOnScroll.forEach((t4) => t4()), this.unsubscribeOnScroll = [], !this.audioData) return;
    const { scrollWidth: t3 } = this.scrollContainer, { right: e3 } = this.progressWrapper.getBoundingClientRect();
    if (this.render(this.audioData), this.isScrollable && t3 !== this.scrollContainer.scrollWidth) {
      const { right: t4 } = this.progressWrapper.getBoundingClientRect();
      let i3 = t4 - e3;
      i3 *= 2, i3 = i3 < 0 ? Math.floor(i3) : Math.ceil(i3), i3 /= 2, this.scrollContainer.scrollLeft += i3;
    }
  }
  zoom(t3) {
    this.options.minPxPerSec = t3, this.reRender();
  }
  scrollIntoView(t3, e3 = false) {
    const { scrollLeft: i3, scrollWidth: s2, clientWidth: n3 } = this.scrollContainer, r3 = t3 * s2, o3 = i3, a3 = i3 + n3, h2 = n3 / 2;
    if (this.isDragging) {
      const t4 = 30;
      r3 + t4 > a3 ? this.scrollContainer.scrollLeft += t4 : r3 - t4 < o3 && (this.scrollContainer.scrollLeft -= t4);
    } else {
      (r3 < o3 || r3 > a3) && (this.scrollContainer.scrollLeft = r3 - (this.options.autoCenter ? h2 : 0));
      const t4 = r3 - i3 - h2;
      e3 && this.options.autoCenter && t4 > 0 && (this.scrollContainer.scrollLeft += Math.min(t4, 10));
    }
    {
      const t4 = this.scrollContainer.scrollLeft, e4 = t4 / s2, i4 = (t4 + n3) / s2;
      this.emit("scroll", e4, i4, t4, t4 + n3);
    }
  }
  renderProgress(t3, e3) {
    if (isNaN(t3)) return;
    const i3 = 100 * t3;
    this.canvasWrapper.style.clipPath = `polygon(${i3}% 0, 100% 0, 100% 100%, ${i3}% 100%)`, this.progressWrapper.style.width = `${i3}%`, this.cursor.style.left = `${i3}%`, this.cursor.style.transform = `translateX(-${100 === Math.round(i3) ? this.options.cursorWidth : 0}px)`, this.isScrollable && this.options.autoScroll && this.scrollIntoView(t3, e3);
  }
  exportImage(e3, i3, s2) {
    return t(this, void 0, void 0, function* () {
      const t3 = this.canvasWrapper.querySelectorAll("canvas");
      if (!t3.length) throw new Error("No waveform data");
      if ("dataURL" === s2) {
        const s3 = Array.from(t3).map((t4) => t4.toDataURL(e3, i3));
        return Promise.resolve(s3);
      }
      return Promise.all(Array.from(t3).map((t4) => new Promise((s3, n3) => {
        t4.toBlob((t5) => {
          t5 ? s3(t5) : n3(new Error("Could not export image"));
        }, e3, i3);
      })));
    });
  }
};
h.MAX_CANVAS_WIDTH = 8e3, h.MAX_NODES = 10;
var l = class extends e {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
};
var d = class extends e {
  constructor(t3 = new AudioContext()) {
    super(), this.bufferNode = null, this.playStartTime = 0, this.playedDuration = 0, this._muted = false, this._playbackRate = 1, this._duration = void 0, this.buffer = null, this.currentSrc = "", this.paused = true, this.crossOrigin = null, this.seeking = false, this.autoplay = false, this.addEventListener = this.on, this.removeEventListener = this.un, this.audioContext = t3, this.gainNode = this.audioContext.createGain(), this.gainNode.connect(this.audioContext.destination);
  }
  load() {
    return t(this, void 0, void 0, function* () {
    });
  }
  get src() {
    return this.currentSrc;
  }
  set src(t3) {
    if (this.currentSrc = t3, this._duration = void 0, !t3) return this.buffer = null, void this.emit("emptied");
    fetch(t3).then((e3) => {
      if (e3.status >= 400) throw new Error(`Failed to fetch ${t3}: ${e3.status} (${e3.statusText})`);
      return e3.arrayBuffer();
    }).then((e3) => this.currentSrc !== t3 ? null : this.audioContext.decodeAudioData(e3)).then((e3) => {
      this.currentSrc === t3 && (this.buffer = e3, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
    });
  }
  _play() {
    var t3;
    if (!this.paused) return;
    this.paused = false, null === (t3 = this.bufferNode) || void 0 === t3 || t3.disconnect(), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode);
    let e3 = this.playedDuration * this._playbackRate;
    e3 >= this.duration && (e3 = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, e3), this.playStartTime = this.audioContext.currentTime, this.bufferNode.onended = () => {
      this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
    };
  }
  _pause() {
    var t3;
    this.paused = true, null === (t3 = this.bufferNode) || void 0 === t3 || t3.stop(), this.playedDuration += this.audioContext.currentTime - this.playStartTime;
  }
  play() {
    return t(this, void 0, void 0, function* () {
      this.paused && (this._play(), this.emit("play"));
    });
  }
  pause() {
    this.paused || (this._pause(), this.emit("pause"));
  }
  stopAt(t3) {
    var e3, i3;
    const s2 = t3 - this.currentTime;
    null === (e3 = this.bufferNode) || void 0 === e3 || e3.stop(this.audioContext.currentTime + s2), null === (i3 = this.bufferNode) || void 0 === i3 || i3.addEventListener("ended", () => {
      this.bufferNode = null, this.pause();
    }, { once: true });
  }
  setSinkId(e3) {
    return t(this, void 0, void 0, function* () {
      return this.audioContext.setSinkId(e3);
    });
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t3) {
    this._playbackRate = t3, this.bufferNode && (this.bufferNode.playbackRate.value = t3);
  }
  get currentTime() {
    return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
  }
  set currentTime(t3) {
    const e3 = !this.paused;
    e3 && this._pause(), this.playedDuration = t3 / this._playbackRate, e3 && this._play(), this.emit("seeking"), this.emit("timeupdate");
  }
  get duration() {
    var t3, e3;
    return null !== (t3 = this._duration) && void 0 !== t3 ? t3 : (null === (e3 = this.buffer) || void 0 === e3 ? void 0 : e3.duration) || 0;
  }
  set duration(t3) {
    this._duration = t3;
  }
  get volume() {
    return this.gainNode.gain.value;
  }
  set volume(t3) {
    this.gainNode.gain.value = t3, this.emit("volumechange");
  }
  get muted() {
    return this._muted;
  }
  set muted(t3) {
    this._muted !== t3 && (this._muted = t3, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
  }
  canPlayType(t3) {
    return /^(audio|video)\//.test(t3);
  }
  getGainNode() {
    return this.gainNode;
  }
  getChannelData() {
    const t3 = [];
    if (!this.buffer) return t3;
    const e3 = this.buffer.numberOfChannels;
    for (let i3 = 0; i3 < e3; i3++) t3.push(this.buffer.getChannelData(i3));
    return t3;
  }
};
var c = { waveColor: "#999", progressColor: "#555", cursorWidth: 1, minPxPerSec: 0, fillParent: true, interact: true, dragToSeek: false, autoScroll: true, autoCenter: true, sampleRate: 8e3 };
var u = class _u extends a {
  static create(t3) {
    return new _u(t3);
  }
  constructor(t3) {
    const e3 = t3.media || ("WebAudio" === t3.backend ? new d() : void 0);
    super({ media: e3, mediaControls: t3.mediaControls, autoplay: t3.autoplay, playbackRate: t3.audioRate }), this.plugins = [], this.decodedData = null, this.subscriptions = [], this.mediaSubscriptions = [], this.abortController = null, this.options = Object.assign({}, c, t3), this.timer = new l();
    const i3 = e3 ? void 0 : this.getMediaElement();
    this.renderer = new h(this.options, i3), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
    const s2 = this.options.url || this.getSrc() || "";
    Promise.resolve().then(() => {
      this.emit("init");
      const { peaks: t4, duration: e4 } = this.options;
      (s2 || t4 && e4) && this.load(s2, t4, e4).catch(() => null);
    });
  }
  updateProgress(t3 = this.getCurrentTime()) {
    return this.renderer.renderProgress(t3 / this.getDuration(), this.isPlaying()), t3;
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      if (!this.isSeeking()) {
        const t3 = this.updateProgress();
        this.emit("timeupdate", t3), this.emit("audioprocess", t3);
      }
    }));
  }
  initPlayerEvents() {
    this.isPlaying() && (this.emit("play"), this.timer.start()), this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", () => {
      const t3 = this.updateProgress();
      this.emit("timeupdate", t3);
    }), this.onMediaEvent("play", () => {
      this.emit("play"), this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause"), this.timer.stop();
    }), this.onMediaEvent("emptied", () => {
      this.timer.stop();
    }), this.onMediaEvent("ended", () => {
      this.emit("timeupdate", this.getDuration()), this.emit("finish");
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }), this.onMediaEvent("error", (t3) => {
      var e3;
      this.emit("error", null !== (e3 = this.getMediaElement().error) && void 0 !== e3 ? e3 : new Error("Media error"));
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(this.renderer.on("click", (t3, e3) => {
      this.options.interact && (this.seekTo(t3), this.emit("interaction", t3 * this.getDuration()), this.emit("click", t3, e3));
    }), this.renderer.on("dblclick", (t3, e3) => {
      this.emit("dblclick", t3, e3);
    }), this.renderer.on("scroll", (t3, e3, i3, s2) => {
      const n3 = this.getDuration();
      this.emit("scroll", t3 * n3, e3 * n3, i3, s2);
    }), this.renderer.on("render", () => {
      this.emit("redraw");
    }), this.renderer.on("rendered", () => {
      this.emit("redrawcomplete");
    }), this.renderer.on("dragstart", (t3) => {
      this.emit("dragstart", t3);
    }), this.renderer.on("dragend", (t3) => {
      this.emit("dragend", t3);
    }));
    {
      let t3;
      this.subscriptions.push(this.renderer.on("drag", (e3) => {
        if (!this.options.interact) return;
        let i3;
        this.renderer.renderProgress(e3), clearTimeout(t3), this.isPlaying() ? i3 = 0 : true === this.options.dragToSeek ? i3 = 200 : "object" == typeof this.options.dragToSeek && void 0 !== this.options.dragToSeek && (i3 = this.options.dragToSeek.debounceTime), t3 = setTimeout(() => {
          this.seekTo(e3);
        }, i3), this.emit("interaction", e3 * this.getDuration()), this.emit("drag", e3);
      }));
    }
  }
  initPlugins() {
    var t3;
    (null === (t3 = this.options.plugins) || void 0 === t3 ? void 0 : t3.length) && this.options.plugins.forEach((t4) => {
      this.registerPlugin(t4);
    });
  }
  unsubscribePlayerEvents() {
    this.mediaSubscriptions.forEach((t3) => t3()), this.mediaSubscriptions = [];
  }
  setOptions(t3) {
    this.options = Object.assign({}, this.options, t3), t3.duration && !t3.peaks && (this.decodedData = i.createBuffer(this.exportPeaks(), t3.duration)), t3.peaks && t3.duration && (this.decodedData = i.createBuffer(t3.peaks, t3.duration)), this.renderer.setOptions(this.options), t3.audioRate && this.setPlaybackRate(t3.audioRate), null != t3.mediaControls && (this.getMediaElement().controls = t3.mediaControls);
  }
  registerPlugin(t3) {
    return t3._init(this), this.plugins.push(t3), this.subscriptions.push(t3.once("destroy", () => {
      this.plugins = this.plugins.filter((e3) => e3 !== t3);
    })), t3;
  }
  getWrapper() {
    return this.renderer.getWrapper();
  }
  getWidth() {
    return this.renderer.getWidth();
  }
  getScroll() {
    return this.renderer.getScroll();
  }
  setScroll(t3) {
    return this.renderer.setScroll(t3);
  }
  setScrollTime(t3) {
    const e3 = t3 / this.getDuration();
    this.renderer.setScrollPercentage(e3);
  }
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(e3, s2, n3, r3) {
    return t(this, void 0, void 0, function* () {
      var t3;
      if (this.emit("load", e3), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, !s2 && !n3) {
        const i3 = this.options.fetchParams || {};
        window.AbortController && !i3.signal && (this.abortController = new AbortController(), i3.signal = null === (t3 = this.abortController) || void 0 === t3 ? void 0 : t3.signal);
        const n4 = (t4) => this.emit("loading", t4);
        s2 = yield o.fetchBlob(e3, n4, i3);
        const r4 = this.options.blobMimeType;
        r4 && (s2 = new Blob([s2], { type: r4 }));
      }
      this.setSrc(e3, s2);
      const a3 = yield new Promise((t4) => {
        const e4 = r3 || this.getDuration();
        e4 ? t4(e4) : this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata", () => t4(this.getDuration()), { once: true }));
      });
      if (!e3 && !s2) {
        const t4 = this.getMediaElement();
        t4 instanceof d && (t4.duration = a3);
      }
      if (n3) this.decodedData = i.createBuffer(n3, a3 || 0);
      else if (s2) {
        const t4 = yield s2.arrayBuffer();
        this.decodedData = yield i.decode(t4, this.options.sampleRate);
      }
      this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData)), this.emit("ready", this.getDuration());
    });
  }
  load(e3, i3, s2) {
    return t(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio(e3, void 0, i3, s2);
      } catch (t3) {
        throw this.emit("error", t3), t3;
      }
    });
  }
  loadBlob(e3, i3, s2) {
    return t(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio("", e3, i3, s2);
      } catch (t3) {
        throw this.emit("error", t3), t3;
      }
    });
  }
  zoom(t3) {
    if (!this.decodedData) throw new Error("No audio loaded");
    this.renderer.zoom(t3), this.emit("zoom", t3);
  }
  getDecodedData() {
    return this.decodedData;
  }
  exportPeaks({ channels: t3 = 2, maxLength: e3 = 8e3, precision: i3 = 1e4 } = {}) {
    if (!this.decodedData) throw new Error("The audio has not been decoded yet");
    const s2 = Math.min(t3, this.decodedData.numberOfChannels), n3 = [];
    for (let t4 = 0; t4 < s2; t4++) {
      const s3 = this.decodedData.getChannelData(t4), r3 = [], o3 = s3.length / e3;
      for (let t5 = 0; t5 < e3; t5++) {
        const e4 = s3.slice(Math.floor(t5 * o3), Math.ceil((t5 + 1) * o3));
        let n4 = 0;
        for (let t6 = 0; t6 < e4.length; t6++) {
          const i4 = e4[t6];
          Math.abs(i4) > Math.abs(n4) && (n4 = i4);
        }
        r3.push(Math.round(n4 * i3) / i3);
      }
      n3.push(r3);
    }
    return n3;
  }
  getDuration() {
    let t3 = super.getDuration() || 0;
    return 0 !== t3 && t3 !== 1 / 0 || !this.decodedData || (t3 = this.decodedData.duration), t3;
  }
  toggleInteraction(t3) {
    this.options.interact = t3;
  }
  setTime(t3) {
    super.setTime(t3), this.updateProgress(t3), this.emit("timeupdate", t3);
  }
  seekTo(t3) {
    const e3 = this.getDuration() * t3;
    this.setTime(e3);
  }
  playPause() {
    return t(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  stop() {
    this.pause(), this.setTime(0);
  }
  skip(t3) {
    this.setTime(this.getCurrentTime() + t3);
  }
  empty() {
    this.load("", [[0]], 1e-3);
  }
  setMediaElement(t3) {
    this.unsubscribePlayerEvents(), super.setMediaElement(t3), this.initPlayerEvents();
  }
  exportImage() {
    return t(this, arguments, void 0, function* (t3 = "image/png", e3 = 1, i3 = "dataURL") {
      return this.renderer.exportImage(t3, e3, i3);
    });
  }
  destroy() {
    var t3;
    this.emit("destroy"), null === (t3 = this.abortController) || void 0 === t3 || t3.abort(), this.plugins.forEach((t4) => t4.destroy()), this.subscriptions.forEach((t4) => t4()), this.unsubscribePlayerEvents(), this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
};
u.BasePlugin = class extends e {
  constructor(t3) {
    super(), this.subscriptions = [], this.options = t3;
  }
  onInit() {
  }
  _init(t3) {
    this.wavesurfer = t3, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((t3) => t3());
  }
}, u.dom = r;

// node_modules/@wavesurfer/react/dist/index.js
function i2(t3, e3) {
  const [n3, i3] = (0, import_react.useState)(null), a3 = (0, import_react.useMemo)(() => Object.entries(e3).flat(), [e3]);
  return (0, import_react.useEffect)(() => {
    if (!(null == t3 ? void 0 : t3.current)) return;
    const n4 = u.create(Object.assign(Object.assign({}, e3), { container: t3.current }));
    return i3(n4), () => {
      n4.destroy();
    };
  }, [t3, ...a3]), n3;
}
var a2 = /^on([A-Z])/;
var u2 = (t3) => a2.test(t3);
function f(t3, e3) {
  const n3 = (0, import_react.useMemo)(() => Object.entries(e3).flat(), [e3]);
  (0, import_react.useEffect)(() => {
    if (!t3) return;
    const n4 = Object.entries(e3);
    if (!n4.length) return;
    const r3 = n4.map(([e4, n5]) => {
      const r4 = e4.replace(a2, (t4, e5) => e5.toLowerCase());
      return t3.on(r4, (...e5) => n5(t3, ...e5));
    });
    return () => {
      r3.forEach((t4) => t4());
    };
  }, [t3, ...n3]);
}
var l2 = (0, import_react.memo)((e3) => {
  const r3 = (0, import_react.useRef)(null), [c3, s2] = function(t3) {
    return (0, import_react.useMemo)(() => {
      const e4 = Object.assign({}, t3), n3 = Object.assign({}, t3);
      for (const t4 in e4) u2(t4) ? delete e4[t4] : delete n3[t4];
      return [e4, n3];
    }, [t3]);
  }(e3);
  return f(i2(r3, c3), s2), (0, import_jsx_runtime.jsx)("div", { ref: r3 });
});
function p(t3) {
  var { container: e3 } = t3;
  const n3 = i2(e3, function(t4, e4) {
    var n4 = {};
    for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && e4.indexOf(r3) < 0 && (n4[r3] = t4[r3]);
    if (null != t4 && "function" == typeof Object.getOwnPropertySymbols) {
      var o3 = 0;
      for (r3 = Object.getOwnPropertySymbols(t4); o3 < r3.length; o3++) e4.indexOf(r3[o3]) < 0 && Object.prototype.propertyIsEnumerable.call(t4, r3[o3]) && (n4[r3[o3]] = t4[r3[o3]]);
    }
    return n4;
  }(t3, ["container"])), s2 = function(t4) {
    const [e4, n4] = (0, import_react.useState)(false), [s3, i3] = (0, import_react.useState)(false), [a3, u3] = (0, import_react.useState)(0);
    return (0, import_react.useEffect)(() => {
      if (!t4) return;
      const e5 = [t4.on("load", () => {
        n4(false), i3(false), u3(0);
      }), t4.on("ready", () => {
        n4(true), i3(false), u3(0);
      }), t4.on("play", () => {
        i3(true);
      }), t4.on("pause", () => {
        i3(false);
      }), t4.on("timeupdate", () => {
        u3(t4.getCurrentTime());
      }), t4.on("destroy", () => {
        n4(false), i3(false);
      })];
      return () => {
        e5.forEach((t5) => t5());
      };
    }, [t4]), (0, import_react.useMemo)(() => ({ isReady: e4, isPlaying: s3, currentTime: a3 }), [s3, a3, e4]);
  }(n3);
  return (0, import_react.useMemo)(() => Object.assign(Object.assign({}, s2), { wavesurfer: n3 }), [s2, n3]);
}
export {
  l2 as default,
  p as useWavesurfer
};
/*! Bundled license information:

@wavesurfer/react/dist/index.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@wavesurfer_react.js.map
